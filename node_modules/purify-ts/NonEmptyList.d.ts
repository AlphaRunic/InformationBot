import { Maybe } from './Maybe';
import { Tuple } from './Tuple';
export declare type NonEmptyListCompliant<T> = T[] & {
    0: T;
};
export interface NonEmptyList<T> extends NonEmptyListCompliant<T> {
    map<U>(this: NonEmptyList<T>, callbackfn: (value: T, index: number, array: NonEmptyList<T>) => U, thisArg?: any): NonEmptyList<U>;
    reverse(this: NonEmptyList<T>): NonEmptyList<T>;
}
export interface NonEmptyListTypeRef {
    <T extends NonEmptyListCompliant<T[number]>>(list: T): NonEmptyList<T[number]>;
    fromArray<T>(source: T[]): Maybe<NonEmptyList<T>>;
    fromTuple<T, U>(source: Tuple<T, U>): NonEmptyList<T | U>;
    unsafeCoerce<T>(source: T[]): NonEmptyList<T>;
    isNonEmpty<T>(list: T[]): list is NonEmptyList<T>;
    head<T>(list: NonEmptyList<T>): T;
    last<T>(list: NonEmptyList<T>): T;
}
export declare const NonEmptyList: NonEmptyListTypeRef;
