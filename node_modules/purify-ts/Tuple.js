"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const TupleConstructor = (fst, snd) => ({
    constructor: exports.Tuple,
    0: fst,
    1: snd,
    length: 2,
    *[Symbol.iterator]() {
        yield fst;
        yield snd;
    },
    toJSON() {
        return this.toArray();
    },
    inspect() {
        return `Tuple(${fst}, ${snd})`;
    },
    toString() {
        return this.inspect();
    },
    fst() {
        return fst;
    },
    snd() {
        return snd;
    },
    equals(other) {
        return fst === other.fst() && snd === other.snd();
    },
    bimap(f, g) {
        return exports.Tuple(f(fst), g(snd));
    },
    mapFirst(f) {
        return exports.Tuple(f(fst), snd);
    },
    map(f) {
        return exports.Tuple(fst, f(snd));
    },
    reduce(reducer, initialValue) {
        return reducer(initialValue, snd);
    },
    toArray() {
        return [fst, snd];
    },
    swap() {
        return exports.Tuple(snd, fst);
    },
    ap(f) {
        return exports.Tuple(fst, f.snd()(snd));
    },
    'fantasy-land/equals'(other) {
        return this.equals(other);
    },
    'fantasy-land/bimap'(f, g) {
        return this.bimap(f, g);
    },
    'fantasy-land/map'(f) {
        return this.map(f);
    },
    'fantasy-land/reduce'(reducer, initialValue) {
        return this.reduce(reducer, initialValue);
    },
    'fantasy-land/ap'(f) {
        return this.ap(f);
    }
});
exports.Tuple = Object.assign(TupleConstructor, {
    fromArray: ([fst, snd]) => {
        return exports.Tuple(fst, snd);
    },
    fanout: (...args) => {
        const [f, g, value] = args;
        switch (args.length) {
            case 3:
                return exports.Tuple(f(value), g(value));
            case 2:
                return (value) => exports.Tuple.fanout(f, g, value);
            default:
                return (g) => (value) => exports.Tuple.fanout(f, g, value);
        }
    }
});
