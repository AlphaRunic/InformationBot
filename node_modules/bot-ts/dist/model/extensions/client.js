"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const discord_js_1 = require("discord.js");
const fs_1 = require("fs");
const path = require("path");
const commands_1 = require("../../commands");
const __1 = require("..");
const Maybe_1 = require("purify-ts/Maybe");
const util_1 = require("../../util");
const default_command_options_1 = require("../default-command-options");
const argument_type_1 = require("../argument-type");
const services_1 = require("../../services");
/**
 * Extension of the Discord.js Client.
 *
 * Contains extra methods and properties for managing commands.
 *
 * @see https://discord.js.org/#/docs/main/master/class/Client
 */
class Client extends discord_js_1.Client {
    constructor(options) {
        super(options);
        /**
         * Holds all of the registered commands.
         */
        this.commands = new discord_js_1.Collection();
        this.userService = new services_1.UserService();
        this.options = options;
        this.on('message', async (msg) => this.onMessage(msg));
    }
    /**
     * Calls a callback when a message containing a command is processed.
     *
     * @param callback The function to call on the message
     */
    onCommand(callback) {
        this.on(__1.Event.COMMAND_RUN, callback);
    }
    /**
     * Calls a callback when a message starting with a prefix but not matching a command is sent.
     *
     * @param callback The function to call on the invalid command
     */
    onInvalidCommand(callback) {
        this.on(__1.Event.INVALID_COMMAND, callback);
    }
    /**
     * Register a command object
     *
     * @param command - The command object
     */
    registerCommand(command) {
        this.findDuplicateAndFail(command);
        this.validateUnregisteredCommandArguments(command);
        this.commands.set(command.options.name, command);
        if (command.options.unknown) {
            if (this.unknownCommand && !this.unknownCommand.options.default) {
                throw new TypeError(`Command ${this.unknownCommand.options.name} is already the unknown command, ${command.options.name} cannot also be it.`);
            }
            this.unknownCommand = command;
        }
    }
    /**
     * Recursively finds all commands in a directory and registers them.
     *
     * @param filePath - The directory that contains commands.
     */
    async registerCommandsIn(filePath) {
        if (typeof filePath === 'string') {
            return this.walk(filePath).then(files => {
                files.forEach(async (file) => {
                    await this.resolveCommand(path.join(filePath, file));
                });
            });
        }
        filePath.forEach(async (p) => {
            await this.registerCommandsIn(p);
        });
    }
    /**
     * Registers the built-in commands.
     *
     * @param options Allows you to disable certain default commands.
     */
    registerDefaultCommands(options = {}) {
        const mergedSettings = Object.assign(Object.assign({}, default_command_options_1.initDefaultCommandOptions()), options);
        if (mergedSettings.help) {
            this.registerCommand(new commands_1.HelpCommand(this));
        }
        if (mergedSettings.unknown) {
            this.registerCommand(new commands_1.UnknownCommand(this));
        }
    }
    /**
     * Helper method to fail when a duplicate command is registered.
     *
     * @param command - The comamnd that was attempted to be registered.
     * @param existingCommand - A command that was previously registered with the same name or alias.
     */
    failDuplicate(command, existingCommand) {
        throw new TypeError(`Unable to register command '${command.options.name}'. I've already registered a command '${existingCommand.options.name}' which either has the same name or shares an alias.`);
    }
    /**
     * This ensures no commands/aliases with the same name are registered.
     *
     * @param command The command to check against all other commands.
     */
    findDuplicateAndFail(command) {
        const commandSameName = __1.Command.find(this, command.options.name);
        if (commandSameName) {
            if (commandSameName.options.default) {
                this.commands.delete(commandSameName.options.name);
                return;
            }
            this.failDuplicate(command, commandSameName);
        }
        if (!command.options.aliases) {
            return;
        }
        for (const alias of command.options.aliases) {
            const commandSameAlias = __1.Command.find(this, alias);
            if (commandSameAlias) {
                if (commandSameAlias.options.default) {
                    this.commands.delete(commandSameAlias.options.name);
                    return;
                }
                this.failDuplicate(command, commandSameAlias);
            }
        }
    }
    /**
     * Converts the user arguments to an array with the same length as the expected arguments array.
     *
     * @param command - The command object.
     * @param args - The array of arguments provided by the user.
     */
    getFormattedArgs(command, args) {
        let formattedArgs = args;
        if (!command.options.args) {
            return args;
        }
        if (args.length > command.options.args.length) {
            const formattedArgStartIndex = command.options.args.length - 1;
            const combinedFinalArg = args.slice(formattedArgStartIndex).join(' ');
            const newArgs = args.slice(0, formattedArgStartIndex);
            newArgs.push(combinedFinalArg);
            formattedArgs = newArgs;
        }
        return formattedArgs;
    }
    /**
     * Gets the prefix used by the user (in case an array was used)
     *
     * @param msg - The CommandMessage representing the user's message
     */
    getPrefixFromMessage(msg) {
        if (msg.channel.type === 'dm') {
            return '';
        }
        if (typeof this.options.commandPrefix === 'string') {
            return this.options.commandPrefix;
        }
        let prefix = '';
        for (const prefixOption of this.options.commandPrefix) {
            if (msg.content.startsWith(prefixOption)) {
                prefix = prefixOption;
                break;
            }
        }
        return prefix;
    }
    /**
     * Handles exceptions generated from command execution.
     */
    async handleCommandError(msg, error) {
        // tslint:disable-next-line: no-non-null-assertion
        const owner = this.users.get(this.options.ownerId);
        const ownerDisplayString = `${owner.username}#${owner.discriminator}`;
        await msg
            .reply(
        // tslint:disable-next-line: no-non-null-assertion
        `An error occurred during the execution of the \`${msg.command.options.name}\` command: ${error.message}\n\nYou should never see this. Please contact ${ownerDisplayString}.`)
            .catch(_ => {
            // swallow
        });
        util_1.Logger.error(error);
    }
    /**
     * Helper method to check if message begins with a command prefix
     *
     * @param msg - The CommandMessage with the user's message
     */
    messageStartsWithPrefix(msg) {
        if (msg.channel.type === 'dm') {
            return true;
        }
        if (typeof this.options.commandPrefix === 'string') {
            return msg.content.startsWith(this.options.commandPrefix);
        }
        for (const prefix of this.options.commandPrefix) {
            if (msg.content.startsWith(prefix)) {
                return true;
            }
        }
        return false;
    }
    /**
     * Handles when a user sends a message.
     *
     * @param msg - CommandMessage object
     */
    async onMessage(msg) {
        if (msg.author.bot) {
            return;
        }
        if (!this.messageStartsWithPrefix(msg)) {
            return;
        }
        await this.parseMessageAsCommand(msg);
    }
    /**
     * Tries to get a command from the user's message and execute it
     *
     * @param msg - The CommandMessage representing the user's message
     */
    async parseMessageAsCommand(msg) {
        const prefix = this.getPrefixFromMessage(msg);
        const withoutPrefix = msg.content.slice(prefix.length).trim();
        const split = withoutPrefix.split(' ');
        const commandName = split[0];
        const args = split.slice(1);
        const command = __1.Command.find(this, commandName);
        if (!command ||
            command.options.unknown ||
            (command.options.guildOnly && msg.guild) ||
            (command.options.ownerOnly && msg.author.id !== this.options.ownerId)) {
            this.emit(__1.Event.INVALID_COMMAND, msg);
            if (this.unknownCommand) {
                msg.command = this.unknownCommand;
                await this.runCommandWithArgs(msg, [commandName]);
            }
            return;
        }
        this.emit(__1.Event.COMMAND_RUN, msg, command, prefix);
        msg.command = command;
        if (command.options.args) {
            return this.runCommandWithArgs(msg, args);
        }
        return this.runCommand(msg, Maybe_1.Nothing);
    }
    // tslint:disable: no-unsafe-any
    /**
     * Tries to get command from a single file.
     *
     * @param filePath - Absolute path of command file.
     */
    async resolveCommand(filePath) {
        let ResolvableCommand;
        try {
            ResolvableCommand = await Promise.resolve().then(() => require(filePath));
        }
        catch (err) {
            // swallow
        }
        if (ResolvableCommand.default) {
            ResolvableCommand = ResolvableCommand.default;
        }
        if (!ResolvableCommand) {
            return;
        }
        const instance = new ResolvableCommand(this);
        if (!instance) {
            return;
        }
        this.registerCommand(instance);
    }
    // tslint:enable: no-unsafe-any
    /**
     * Wrapper method to execute a command. Checks permission and handles exceptions.
     *
     * @param msg - The message object.
     * @param command - The command object to be ran.
     * @param args - Command args.
     */
    async runCommand(msg, args) {
        if (!msg.command) {
            return;
        }
        const hasPermission = await msg.command.hasPermission(msg);
        if (typeof hasPermission === 'string') {
            await msg.reply(hasPermission);
            return;
        }
        if (!hasPermission) {
            await msg.reply(`You do not have permission to use the \`${msg.command.options.name}\` command.`);
            return;
        }
        await msg.command
            .run(msg, args.extract())
            .catch(async (err) => this.handleCommandError(msg, err));
    }
    /**
     * Helper method to validate args and run command with args.
     *
     * @param msg - The message object.
     * @param command - The command object to be ran.
     * @param args - Command args.
     */
    async runCommandWithArgs(msg, args) {
        if (!msg.command) {
            return;
        }
        if (!msg.command.options.args) {
            return this.runCommand(msg, Maybe_1.Nothing);
        }
        const required = msg.command.options.args.filter(arg => !arg.optional && arg.default === undefined);
        if (required.length > args.length) {
            await msg.reply(`Insufficient arguments. Expected at least ${required.length}.`); // TODO: Make this better. Maybe a pretty embed as well?
            return;
        }
        const formattedArgs = this.getFormattedArgs(msg.command, args);
        const argsValid = await this.validateArgs(msg, msg.command, formattedArgs);
        if (!argsValid) {
            return;
        }
        const argsObject = this.mapArgsToObject(msg, formattedArgs);
        return this.runCommand(msg, argsObject);
    }
    /**
     * Converts an array of arguments to an object key/value store with the designated type from the command args.
     *
     * @param command - The command object.
     * @param args - The formatted argument string array.
     */
    mapArgsToObject(msg, args) {
        return Maybe_1.Maybe.fromNullable(msg.command)
            .chainNullable(command => command.options.args)
            .map(commandArgs => commandArgs.map((argument, index) => ({
            [argument.key]: this.resolveArgumentType(args[index] || argument.default || '', argument.type, msg.guild).extract()
        })))
            .map(keyValueArray => keyValueArray.reduce((occumulator, value) => (Object.assign(Object.assign({}, occumulator), value)), {}));
    }
    resolveArgumentType(value, argumentType, guild) {
        if (Array.isArray(argumentType)) {
            for (const type of argumentType) {
                const resolved = argument_type_1.ArgumentTypeResolver(type)({
                    input: value,
                    guild,
                    userService: this.userService
                });
                if (resolved.isJust()) {
                    return resolved;
                }
            }
            return Maybe_1.Maybe.empty();
        }
        return argument_type_1.ArgumentTypeResolver(argumentType)({
            input: value,
            guild,
            userService: this.userService
        });
    }
    /**
     * Validates user arguments against required command arguments.
     *
     * @param msg - The message object.
     * @param command - The command object.
     * @param args - The arguments provided by the user.
     */
    async validateArgs(msg, command, args) {
        if (!command.options.args) {
            return true;
        }
        for (let i = 0; i < command.options.args.length; i++) {
            const commandArg = command.options.args[i];
            if (commandArg.optional && !args[i]) {
                return true;
            }
            if (commandArg.default && !args[i]) {
                return true;
            }
            const expectedType = [...commandArg.type];
            let foundType = false;
            for (const t of expectedType) {
                if (this.validateType(msg, t, args[i])) {
                    foundType = true;
                    break;
                }
            }
            if (!foundType) {
                await msg.reply(`Argument type mismatch at '${args[i]}'`);
                return false;
            }
        }
        for (let i = 0; i < args.length; i++) {
            return true;
        }
        return true;
    }
    /**
     * Validates a value against a single type
     *
     * @param msg - The message object.
     * @param expected - The expected type.
     * @param value - The value from the user.
     */
    validateType(msg, expected, value) {
        switch (expected) {
            case 'number':
                return !!Number(value);
            case 'user':
                if (!msg.guild) {
                    return false;
                }
                return this.userService.getMemberFromMention(msg.guild, value).isJust();
            default:
                return true;
        }
    }
    /**
     * Tests a command's arguments for duplicate keys and for optional arguments before required ones.
     *
     * @param command The command to test the arguments of.
     */
    validateUnregisteredCommandArguments(command) {
        if (command.options.args) {
            const keys = [];
            let optional = false;
            for (const arg of command.options.args) {
                if (arg.optional) {
                    optional = true;
                }
                else if (optional) {
                    throw new TypeError(`Required argument ${arg.key} of command ${command.options.name} is after an optional argument.`);
                }
                if (keys.includes(arg.key)) {
                    throw new TypeError(`Argument key ${arg.key} is used at least twice in command ${command.options.name}`);
                }
                keys.push(arg.key);
            }
        }
    }
    // source: https://gist.github.com/kethinov/6658166#gistcomment-2733303
    /**
     * Gets all files in directory, recursively.
     */
    async walk(dir) {
        const files = await fs_1.promises.readdir(dir);
        const fileList = [];
        for (const file of files) {
            const filepath = path.join(dir, file);
            const stat = await fs_1.promises.stat(filepath);
            if (stat.isDirectory()) {
                fileList.push(...(await this.walk(filepath)).map(f => path.join(path.parse(filepath).base, f)));
            }
            else {
                fileList.push(file);
            }
        }
        return fileList;
    }
}
exports.Client = Client;
//# sourceMappingURL=client.js.map